#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/Environment/Environment.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>
#include <Exploit/Environment/Yielding/Yielding.hpp>

void TaskScheduler::SetProtoCapabilities(Proto* Proto, uintptr_t* Capabilities)
{
    Proto->userdata = Capabilities;
    for (int i = 0; i < Proto->sizep; ++i)
        SetProtoCapabilities(Proto->p[i], Capabilities);
}

void TaskScheduler::SetThreadCapabilities(lua_State* L, int Level, uintptr_t Capabilities)
{
    L->userdata->Identity = Level;
    L->userdata->Capabilities = Capabilities;
}

uintptr_t TaskScheduler::GetDataModel()
{
	uintptr_t FakeDataModel = *reinterpret_cast<uintptr_t*>(Offsets::DataModel::FakeDataModelPointer);
    uintptr_t DataModel = *reinterpret_cast<uintptr_t*>(FakeDataModel + Offsets::DataModel::FakeDataModelToDataModel);

	return DataModel;
}

uintptr_t TaskScheduler::GetScriptContext(uintptr_t DataModel)
{
    uintptr_t Children = *reinterpret_cast<uintptr_t*>(DataModel + Offsets::DataModel::Children);
	uintptr_t ScriptContext = *reinterpret_cast<uintptr_t*>(*reinterpret_cast<uintptr_t*>(Children) + Offsets::DataModel::ScriptContext);

    return ScriptContext;
}

lua_State* TaskScheduler::GetLuaStateForInstance(uintptr_t Instance)
{
    *reinterpret_cast<BOOLEAN*>(Instance + Offsets::ExtraSpace::RequireBypass) = TRUE;

    auto Address = Instance + Offsets::ExtraSpace::InstanceToLuaState;
    auto EncryptedState = reinterpret_cast<uint32_t*>(Address);

    uint32_t Low = EncryptedState[0] - static_cast<uint32_t>(Address);
    uint32_t High = EncryptedState[1] - static_cast<uint32_t>(Address);
    return reinterpret_cast<lua_State*>((static_cast<uint64_t>(High) << 32) | Low);
}

int ScriptsHandler(lua_State* L)
{
    if (!SharedVariables::ExecutionRequests.empty())
    {
        Execution::ExecuteScript(SharedVariables::ExploitThread, SharedVariables::ExecutionRequests.front());
        SharedVariables::ExecutionRequests.erase(SharedVariables::ExecutionRequests.begin());
    }
    Yielding::RunYield();

    return 0;
}

void SetupExecution(lua_State* L)
{
    lua_getglobal(L, "game");
    lua_getfield(L, -1, "GetService");
    lua_pushvalue(L, -2);

    lua_pushstring(L, "RunService");
    lua_pcall(L, 2, 1, 0);

    lua_getfield(L, -1, "RenderStepped");
    lua_getfield(L, -1, "Connect");
    lua_pushvalue(L, -2);

    lua_pushcclosure(L, ScriptsHandler, nullptr, 0);
    lua_pcall(L, 2, 0, 0);
    lua_pop(L, 2);
}

bool TaskScheduler::SetupExploit()
{
	uintptr_t ScriptContext = TaskScheduler::GetScriptContext(SharedVariables::LastDataModel);
    lua_State* RobloxState = TaskScheduler::GetLuaStateForInstance(ScriptContext);

    SharedVariables::ExploitThread = lua_newthread(RobloxState);
	TaskScheduler::SetThreadCapabilities(SharedVariables::ExploitThread, 8, MaxCapabilities);
	Environment::SetupEnvironment(SharedVariables::ExploitThread);
    SetupExecution(SharedVariables::ExploitThread);

    return true;
}

void TaskScheduler::RequestExecution(std::string Script)
{
    SharedVariables::ExecutionRequests.push_back(Script);
}